// SPDX-License-Identifier: BUSL-1.1
//
// Copyright (C) 2023, Berachain Foundation. All rights reserved.
// Use of this software is govered by the Business Source License included
// in the LICENSE file of this repository and at www.mariadb.com/bsl11.
//
// ANY USE OF THE LICENSED WORK IN VIOLATION OF THIS LICENSE WILL AUTOMATICALLY
// TERMINATE YOUR RIGHTS UNDER THIS LICENSE FOR THE CURRENT AND ALL OTHER
// VERSIONS OF THE LICENSED WORK.
//
// THIS LICENSE DOES NOT GRANT YOU ANY RIGHT IN ANY TRADEMARK OR LOGO OF
// LICENSOR OR ITS AFFILIATES (PROVIDED THAT YOU MAY USE A TRADEMARK OR LOGO OF
// LICENSOR AS EXPRESSLY REQUIRED BY THIS LICENSE).
//
// TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE LICENSED WORK IS PROVIDED ON
// AN ‚ÄúAS IS‚Äù BASIS. LICENSOR HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS,
// EXPRESS OR IMPLIED, INCLUDING (WITHOUT LIMITATION) WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND
// TITLE.

package miner

import (
	"context"
	"errors"
	"fmt"
	"math/big"
	"sync"

	"cosmossdk.io/log"

	abci "github.com/cometbft/cometbft/abci/types"

	"github.com/cosmos/cosmos-sdk/baseapp"
	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkmempool "github.com/cosmos/cosmos-sdk/types/mempool"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/consensus/misc"
	coretypes "github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/miner"

	"pkg.berachain.dev/polaris/cosmos/runtime/polaris/mempool"
	"pkg.berachain.dev/polaris/eth/core"
	"pkg.berachain.dev/polaris/eth/core/types"
)

const maxTxBytes = 1000000 // 1mb

type worker struct {
	config     miner.Config
	cb         CoinbaseProvider
	chain      core.Blockchain
	logger     log.Logger
	mempool    *mempool.WrappedGethTxPool
	txVerifier baseapp.ProposalTxVerifier

	prepCh     chan *ProposalRequest
	procCh     chan *ProcessRequest
	prepRespCh chan *ProposedBlock
	procRespCh chan *ProcessedBlock
	stopCh     chan struct{}

	mu    sync.RWMutex // The lock used to protect the coinbase and extra fields
	extra []byte

	pendingHeader *types.Header
	// snapshotMu       sync.RWMutex
	// snapshotBlock *types.Block
	// snapshotReceipts types.Receipts
}

// newWorker returns a new worker.
func newWorker(
	logger log.Logger, mp *mempool.WrappedGethTxPool,
	txVerifier baseapp.ProposalTxVerifier,
	proposalHandler PolarisProposalHandler,
	cb CoinbaseProvider,
) *worker {
	return &worker{
		logger:     logger.With("module", "polaris-miner"),
		mempool:    mp,
		txVerifier: txVerifier,
		prepCh:     proposalHandler.prepCh,
		procCh:     proposalHandler.procCh,
		prepRespCh: proposalHandler.prepRespCh,
		procRespCh: proposalHandler.procRespCh,
		stopCh:     make(chan struct{}),
		cb:         cb,
		config:     miner.DefaultConfig,
	}
}

// Start starts the miner.
func (w *worker) start() {
	go w.mainLoop()
}

// Stop stops the miner.
func (w *worker) stop() {
	close(w.prepCh)
	close(w.procCh)
	close(w.prepRespCh)
	close(w.procRespCh)

	w.stopCh <- struct{}{}
}

// loop is the main loop of the miner.
func (w *worker) mainLoop() {
	for {
		select {
		case req := <-w.prepCh:
			w.prepRespCh <- w.buildBlock(req.ctx, req.content.Txs)
		case req := <-w.procCh:
			w.procRespCh <- w.processBlock(req.ctx, req.content.Txs)
		case <-w.stopCh:
			return
		}
	}
}

// generateParams wraps various of settings for generating sealing task.
type generateParams struct {
	timestamp   uint64                // The timstamp for sealing task
	forceTime   bool                  // Flag whether the given timestamp is immutable or not
	parentHash  common.Hash           // Parent block hash, empty means the latest chain head
	coinbase    common.Address        // The fee recipient address for including transaction
	random      common.Hash           // The randomness generated by beacon chain, empty before the merge
	withdrawals coretypes.Withdrawals // List of withdrawals to include in block.
	noUncle     bool                  // Flag whether the uncle block inclusion is allowed
	noTxs       bool                  // Flag whether an empty block without any transaction is expected
}

// prepareWork constructs the sealing task according to the given parameters,
// either based on the last chain head or specified parent. In this function
// the pending transactions are not filled yet, only the empty task returned.
func (w *worker) prepareWork(genParams *generateParams) (*environment, error) {
	w.mu.RLock()
	defer w.mu.RUnlock()

	// Find the parent block for sealing task
	parent := w.chain.CurrentBlock()
	if genParams.parentHash != (common.Hash{}) {
		block := w.chain.GetBlockByHash(genParams.parentHash)
		if block == nil {
			return nil, fmt.Errorf("missing parent")
		}
		parent = block.Header()
	}
	// Sanity check the timestamp correctness, recap the timestamp
	// to parent+1 if the mutation is allowed.
	timestamp := genParams.timestamp
	if parent.Time >= timestamp {
		if genParams.forceTime {
			return nil, fmt.Errorf("invalid timestamp, parent %d given %d", parent.Time, timestamp)
		}
		timestamp = parent.Time + 1
	}
	// Construct the sealing block header.
	header := &types.Header{
		ParentHash: parent.Hash(),
		Number:     new(big.Int).Add(parent.Number, common.Big1),
		GasLimit:   core.CalcGasLimit(parent.GasLimit, w.config.GasCeil),
		Time:       timestamp,
		Coinbase:   genParams.coinbase,
	}
	// Set the extra field.
	if len(w.extra) != 0 {
		header.Extra = w.extra
	}
	// Set the randomness field from the beacon chain if it's available.
	if genParams.random != (common.Hash{}) {
		header.MixDigest = genParams.random
	}

	chainConfig := w.chain.Config()
	// Set baseFee and GasLimit if we are on an EIP-1559 chain
	if chainConfig.IsLondon(header.Number) {
		header.BaseFee = misc.CalcBaseFee(chainConfig, parent)
		if !chainConfig.IsLondon(parent.Number) {
			parentGasLimit := parent.GasLimit * chainConfig.ElasticityMultiplier()
			header.GasLimit = core.CalcGasLimit(parentGasLimit, w.config.GasCeil)
		}
	}

	// TODO: prepare the blockchain (or engine) here, once it's less scary.
	// Run the consensus preparation with the default or customized consensus engine.
	// if err := w.engine.Prepare(w.chain, header); err != nil {
	// 	w.logger.Error("Failed to prepare header for sealing", "err", err)
	// 	return nil, err
	// }

	// Could potentially happen if starting to mine in an odd state.
	// Note genParams.coinbase can be different with header.Coinbase
	// since clique algorithm can modify the coinbase field in header.
	env, err := w.makeEnv(parent, header, genParams.coinbase)
	if err != nil {
		w.logger.Error("Failed to create sealing context", "err", err)
		return nil, err
	}

	return env, nil
}

// BuildBlock builds a block using the provided mempool and txs.s.
func (w *worker) buildBlock(ctx context.Context, txs [][]byte) *ProposedBlock {
	var (
		selectedTxs  [][]byte
		totalTxBytes int64
		bz           []byte
	)

	env, err := w.prepareWork(&generateParams{
		timestamp:   uint64(sdk.UnwrapSDKContext(ctx).BlockTime().Unix()),
		coinbase:    w.cb.CoinbaseFromContext(ctx),
		random:      common.Hash{}, // not used in CometBFT
		noUncle:     true,          // CometBFT has no reorgs
		noTxs:       len(txs) == 0,
		withdrawals: coretypes.Withdrawals{}, // this is an ethereum specific thing
	})
	if err != nil {
		panic(err)
	}

	w.pendingHeader = env.header
	w.mempool.Prepare(env.header.BaseFee, env.signer)
	w.logger.Info("ü¶∫ building block", "seal_hash", env.header.Hash())
	iterator := w.mempool.Select(ctx, txs)

	for iterator != nil {
		memTx := iterator.Tx()

		// NOTE: Since transaction verification was already executed in CheckTx,
		// which calls mempool.Insert, in theory everything in the pool should be
		// valid. But some mempool implementations may insert invalid txs, so we
		// check again.
		bz, err = w.txVerifier.PrepareProposalVerifyTx(memTx)
		if err != nil {
			err = w.mempool.Remove(memTx)
			if err != nil && !errors.Is(err, sdkmempool.ErrTxNotFound) {
				panic(err)
			}
		} else {
			// TODO track gas consumption fuck byte size.
			txSize := int64(len(bz))
			if totalTxBytes += txSize; totalTxBytes <= maxTxBytes {
				selectedTxs = append(selectedTxs, bz)
			} else {
				break
			}
		}

		iterator = iterator.Next()
	}

	return &ProposedBlock{ctx, &abci.ResponsePrepareProposal{Txs: selectedTxs}, nil}
}

// ProcessBlock processes a block using the provided mempool and txs.
func (w *worker) processBlock(ctx context.Context, txs [][]byte) *ProcessedBlock {
	env, err := w.prepareWork(&generateParams{
		timestamp:   uint64(sdk.UnwrapSDKContext(ctx).BlockTime().Unix()),
		coinbase:    w.cb.CoinbaseFromContext(ctx),
		random:      common.Hash{}, // not used in CometBFT
		noUncle:     true,          // CometBFT has no reorgs
		noTxs:       len(txs) == 0,
		withdrawals: coretypes.Withdrawals{}, // this is an ethereum specific thing
	})
	if err != nil {
		return &ProcessedBlock{ctx, &abci.ResponseProcessProposal{
			Status: abci.ResponseProcessProposal_REJECT,
		}, nil}
	}

	w.pendingHeader = env.header
	w.mempool.Prepare(env.header.BaseFee, env.signer)
	w.logger.Info("üöú processing block", "seal_hash", env.header.Hash())
	for _, txBytes := range txs {
		_, err = w.txVerifier.ProcessProposalVerifyTx(txBytes)
		if err != nil {
			return &ProcessedBlock{
				ctx,
				&abci.ResponseProcessProposal{
					Status: abci.ResponseProcessProposal_REJECT,
				}, nil}
		}
	}

	return &ProcessedBlock{
		ctx,
		&abci.ResponseProcessProposal{Status: abci.ResponseProcessProposal_ACCEPT},
		nil,
	}
}

// makeEnv creates a new environment for the sealing block.
//
//nolint:unparam // temporary
func (w *worker) makeEnv(_ *types.Header, header *types.Header, coinbase common.Address) (*environment, error) {
	// Note the passed coinbase may be different with header.Coinbase.
	env := &environment{
		signer:   types.MakeSigner(w.chain.Config(), header.Number, header.Time),
		header:   header,
		coinbase: coinbase,
	}
	return env, nil
}
