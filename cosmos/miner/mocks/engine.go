// Code generated by mockery v2.34.1. DO NOT EDIT.

package mocks

import (
	big "math/big"

	common "github.com/ethereum/go-ethereum/common"
	consensus "github.com/ethereum/go-ethereum/consensus"

	mock "github.com/stretchr/testify/mock"

	rpc "github.com/ethereum/go-ethereum/rpc"

	state "github.com/ethereum/go-ethereum/core/state"

	types "github.com/ethereum/go-ethereum/core/types"
)

// Engine is an autogenerated mock type for the Engine type
type Engine struct {
	mock.Mock
}

type Engine_Expecter struct {
	mock *mock.Mock
}

func (_m *Engine) EXPECT() *Engine_Expecter {
	return &Engine_Expecter{mock: &_m.Mock}
}

// APIs provides a mock function with given fields: chain
func (_m *Engine) APIs(chain consensus.ChainHeaderReader) []rpc.API {
	var r0 []rpc.API
	return r0
}

// Engine_APIs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'APIs'
type Engine_APIs_Call struct {
	*mock.Call
}

// APIs is a helper method to define mock.On call
//   - chain consensus.ChainHeaderReader
func (_e *Engine_Expecter) APIs(chain interface{}) *Engine_APIs_Call {
	return &Engine_APIs_Call{Call: _e.mock.On("APIs", chain)}
}

func (_c *Engine_APIs_Call) Run(run func(chain consensus.ChainHeaderReader)) *Engine_APIs_Call {
	return _c
}

func (_c *Engine_APIs_Call) Return(_a0 []rpc.API) *Engine_APIs_Call {
	return _c
}

func (_c *Engine_APIs_Call) RunAndReturn(run func(consensus.ChainHeaderReader) []rpc.API) *Engine_APIs_Call {
	_c.Call.Return(run)
	return _c
}

// Author provides a mock function with given fields: header
func (_m *Engine) Author(header *types.Header) (common.Address, error) {
	var r0 common.Address
	var r1 error
	return r0, r1
}

// Engine_Author_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Author'
type Engine_Author_Call struct {
	*mock.Call
}

// Author is a helper method to define mock.On call
//   - header *types.Header
func (_e *Engine_Expecter) Author(header interface{}) *Engine_Author_Call {
	return &Engine_Author_Call{Call: _e.mock.On("Author", header)}
}

func (_c *Engine_Author_Call) Run(run func(header *types.Header)) *Engine_Author_Call {
	return _c
}

func (_c *Engine_Author_Call) Return(_a0 common.Address, _a1 error) *Engine_Author_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Engine_Author_Call) RunAndReturn(run func(*types.Header) (common.Address, error)) *Engine_Author_Call {
	_c.Call.Return(run)
	return _c
}

// CalcDifficulty provides a mock function with given fields: chain, time, parent
func (_m *Engine) CalcDifficulty(chain consensus.ChainHeaderReader, time uint64, parent *types.Header) *big.Int {
	var r0 *big.Int
	return r0
}

// Engine_CalcDifficulty_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CalcDifficulty'
type Engine_CalcDifficulty_Call struct {
	*mock.Call
}

// CalcDifficulty is a helper method to define mock.On call
//   - chain consensus.ChainHeaderReader
//   - time uint64
//   - parent *types.Header
func (_e *Engine_Expecter) CalcDifficulty(chain interface{}, time interface{}, parent interface{}) *Engine_CalcDifficulty_Call {
	return &Engine_CalcDifficulty_Call{Call: _e.mock.On("CalcDifficulty", chain, time, parent)}
}

func (_c *Engine_CalcDifficulty_Call) Run(run func(chain consensus.ChainHeaderReader, time uint64, parent *types.Header)) *Engine_CalcDifficulty_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(consensus.ChainHeaderReader), args[1].(uint64), args[2].(*types.Header))
	})
	return _c
}

func (_c *Engine_CalcDifficulty_Call) Return(_a0 *big.Int) *Engine_CalcDifficulty_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Engine_CalcDifficulty_Call) RunAndReturn(run func(consensus.ChainHeaderReader, uint64, *types.Header) *big.Int) *Engine_CalcDifficulty_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function with given fields:
func (_m *Engine) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Engine_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type Engine_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *Engine_Expecter) Close() *Engine_Close_Call {
	return &Engine_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *Engine_Close_Call) Run(run func()) *Engine_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Engine_Close_Call) Return(_a0 error) *Engine_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Engine_Close_Call) RunAndReturn(run func() error) *Engine_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Finalize provides a mock function with given fields: chain, header, _a2, txs, uncles, withdrawals
func (_m *Engine) Finalize(chain consensus.ChainHeaderReader, header *types.Header, _a2 state.StateDBI, txs []*types.Transaction, uncles []*types.Header, withdrawals []*types.Withdrawal) {
	_m.Called(chain, header, _a2, txs, uncles, withdrawals)
}

// Engine_Finalize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Finalize'
type Engine_Finalize_Call struct {
	*mock.Call
}

// Finalize is a helper method to define mock.On call
//   - chain consensus.ChainHeaderReader
//   - header *types.Header
//   - _a2 state.StateDBI
//   - txs []*types.Transaction
//   - uncles []*types.Header
//   - withdrawals []*types.Withdrawal
func (_e *Engine_Expecter) Finalize(chain interface{}, header interface{}, _a2 interface{}, txs interface{}, uncles interface{}, withdrawals interface{}) *Engine_Finalize_Call {
	return &Engine_Finalize_Call{Call: _e.mock.On("Finalize", chain, header, _a2, txs, uncles, withdrawals)}
}

func (_c *Engine_Finalize_Call) Run(run func(chain consensus.ChainHeaderReader, header *types.Header, _a2 state.StateDBI, txs []*types.Transaction, uncles []*types.Header, withdrawals []*types.Withdrawal)) *Engine_Finalize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(consensus.ChainHeaderReader), args[1].(*types.Header), args[2].(state.StateDBI), args[3].([]*types.Transaction), args[4].([]*types.Header), args[5].([]*types.Withdrawal))
	})
	return _c
}

func (_c *Engine_Finalize_Call) Return() *Engine_Finalize_Call {
	_c.Call.Return()
	return _c
}

func (_c *Engine_Finalize_Call) RunAndReturn(run func(consensus.ChainHeaderReader, *types.Header, state.StateDBI, []*types.Transaction, []*types.Header, []*types.Withdrawal)) *Engine_Finalize_Call {
	_c.Call.Return(run)
	return _c
}

// FinalizeAndAssemble provides a mock function with given fields: chain, header, _a2, txs, uncles, receipts, withdrawals
func (_m *Engine) FinalizeAndAssemble(chain consensus.ChainHeaderReader, header *types.Header, _a2 state.StateDBI, txs []*types.Transaction, uncles []*types.Header, receipts []*types.Receipt, withdrawals []*types.Withdrawal) (*types.Block, error) {
	ret := _m.Called(chain, header, _a2, txs, uncles, receipts, withdrawals)

	var r0 *types.Block
	var r1 error
	if rf, ok := ret.Get(0).(func(consensus.ChainHeaderReader, *types.Header, state.StateDBI, []*types.Transaction, []*types.Header, []*types.Receipt, []*types.Withdrawal) (*types.Block, error)); ok {
		return rf(chain, header, _a2, txs, uncles, receipts, withdrawals)
	}
	if rf, ok := ret.Get(0).(func(consensus.ChainHeaderReader, *types.Header, state.StateDBI, []*types.Transaction, []*types.Header, []*types.Receipt, []*types.Withdrawal) *types.Block); ok {
		r0 = rf(chain, header, _a2, txs, uncles, receipts, withdrawals)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Block)
		}
	}

	if rf, ok := ret.Get(1).(func(consensus.ChainHeaderReader, *types.Header, state.StateDBI, []*types.Transaction, []*types.Header, []*types.Receipt, []*types.Withdrawal) error); ok {
		r1 = rf(chain, header, _a2, txs, uncles, receipts, withdrawals)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Engine_FinalizeAndAssemble_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FinalizeAndAssemble'
type Engine_FinalizeAndAssemble_Call struct {
	*mock.Call
}

// FinalizeAndAssemble is a helper method to define mock.On call
//   - chain consensus.ChainHeaderReader
//   - header *types.Header
//   - _a2 state.StateDBI
//   - txs []*types.Transaction
//   - uncles []*types.Header
//   - receipts []*types.Receipt
//   - withdrawals []*types.Withdrawal
func (_e *Engine_Expecter) FinalizeAndAssemble(chain interface{}, header interface{}, _a2 interface{}, txs interface{}, uncles interface{}, receipts interface{}, withdrawals interface{}) *Engine_FinalizeAndAssemble_Call {
	return &Engine_FinalizeAndAssemble_Call{Call: _e.mock.On("FinalizeAndAssemble", chain, header, _a2, txs, uncles, receipts, withdrawals)}
}

func (_c *Engine_FinalizeAndAssemble_Call) Run(run func(chain consensus.ChainHeaderReader, header *types.Header, _a2 state.StateDBI, txs []*types.Transaction, uncles []*types.Header, receipts []*types.Receipt, withdrawals []*types.Withdrawal)) *Engine_FinalizeAndAssemble_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(consensus.ChainHeaderReader), args[1].(*types.Header), args[2].(state.StateDBI), args[3].([]*types.Transaction), args[4].([]*types.Header), args[5].([]*types.Receipt), args[6].([]*types.Withdrawal))
	})
	return _c
}

func (_c *Engine_FinalizeAndAssemble_Call) Return(_a0 *types.Block, _a1 error) *Engine_FinalizeAndAssemble_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Engine_FinalizeAndAssemble_Call) RunAndReturn(run func(consensus.ChainHeaderReader, *types.Header, state.StateDBI, []*types.Transaction, []*types.Header, []*types.Receipt, []*types.Withdrawal) (*types.Block, error)) *Engine_FinalizeAndAssemble_Call {
	_c.Call.Return(run)
	return _c
}

// Prepare provides a mock function with given fields: chain, header
func (_m *Engine) Prepare(chain consensus.ChainHeaderReader, header *types.Header) error {
	ret := _m.Called(chain, header)

	var r0 error
	if rf, ok := ret.Get(0).(func(consensus.ChainHeaderReader, *types.Header) error); ok {
		r0 = rf(chain, header)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Engine_Prepare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Prepare'
type Engine_Prepare_Call struct {
	*mock.Call
}

// Prepare is a helper method to define mock.On call
//   - chain consensus.ChainHeaderReader
//   - header *types.Header
func (_e *Engine_Expecter) Prepare(chain interface{}, header interface{}) *Engine_Prepare_Call {
	return &Engine_Prepare_Call{Call: _e.mock.On("Prepare", chain, header)}
}

func (_c *Engine_Prepare_Call) Run(run func(chain consensus.ChainHeaderReader, header *types.Header)) *Engine_Prepare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(consensus.ChainHeaderReader), args[1].(*types.Header))
	})
	return _c
}

func (_c *Engine_Prepare_Call) Return(_a0 error) *Engine_Prepare_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Engine_Prepare_Call) RunAndReturn(run func(consensus.ChainHeaderReader, *types.Header) error) *Engine_Prepare_Call {
	_c.Call.Return(run)
	return _c
}

// Seal provides a mock function with given fields: chain, block, results, stop
func (_m *Engine) Seal(chain consensus.ChainHeaderReader, block *types.Block, results chan<- *types.Block, stop <-chan struct{}) error {
	ret := _m.Called(chain, block, results, stop)

	var r0 error
	if rf, ok := ret.Get(0).(func(consensus.ChainHeaderReader, *types.Block, chan<- *types.Block, <-chan struct{}) error); ok {
		r0 = rf(chain, block, results, stop)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Engine_Seal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Seal'
type Engine_Seal_Call struct {
	*mock.Call
}

// Seal is a helper method to define mock.On call
//   - chain consensus.ChainHeaderReader
//   - block *types.Block
//   - results chan<- *types.Block
//   - stop <-chan struct{}
func (_e *Engine_Expecter) Seal(chain interface{}, block interface{}, results interface{}, stop interface{}) *Engine_Seal_Call {
	return &Engine_Seal_Call{Call: _e.mock.On("Seal", chain, block, results, stop)}
}

func (_c *Engine_Seal_Call) Run(run func(chain consensus.ChainHeaderReader, block *types.Block, results chan<- *types.Block, stop <-chan struct{})) *Engine_Seal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(consensus.ChainHeaderReader), args[1].(*types.Block), args[2].(chan<- *types.Block), args[3].(<-chan struct{}))
	})
	return _c
}

func (_c *Engine_Seal_Call) Return(_a0 error) *Engine_Seal_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Engine_Seal_Call) RunAndReturn(run func(consensus.ChainHeaderReader, *types.Block, chan<- *types.Block, <-chan struct{}) error) *Engine_Seal_Call {
	_c.Call.Return(run)
	return _c
}

// SealHash provides a mock function with given fields: header
func (_m *Engine) SealHash(header *types.Header) common.Hash {
	ret := _m.Called(header)

	var r0 common.Hash
	if rf, ok := ret.Get(0).(func(*types.Header) common.Hash); ok {
		r0 = rf(header)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	return r0
}

// Engine_SealHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SealHash'
type Engine_SealHash_Call struct {
	*mock.Call
}

// SealHash is a helper method to define mock.On call
//   - header *types.Header
func (_e *Engine_Expecter) SealHash(header interface{}) *Engine_SealHash_Call {
	return &Engine_SealHash_Call{Call: _e.mock.On("SealHash", header)}
}

func (_c *Engine_SealHash_Call) Run(run func(header *types.Header)) *Engine_SealHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*types.Header))
	})
	return _c
}

func (_c *Engine_SealHash_Call) Return(_a0 common.Hash) *Engine_SealHash_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Engine_SealHash_Call) RunAndReturn(run func(*types.Header) common.Hash) *Engine_SealHash_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyHeader provides a mock function with given fields: chain, header
func (_m *Engine) VerifyHeader(chain consensus.ChainHeaderReader, header *types.Header) error {
	ret := _m.Called(chain, header)

	var r0 error
	if rf, ok := ret.Get(0).(func(consensus.ChainHeaderReader, *types.Header) error); ok {
		r0 = rf(chain, header)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Engine_VerifyHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyHeader'
type Engine_VerifyHeader_Call struct {
	*mock.Call
}

// VerifyHeader is a helper method to define mock.On call
//   - chain consensus.ChainHeaderReader
//   - header *types.Header
func (_e *Engine_Expecter) VerifyHeader(chain interface{}, header interface{}) *Engine_VerifyHeader_Call {
	return &Engine_VerifyHeader_Call{Call: _e.mock.On("VerifyHeader", chain, header)}
}

func (_c *Engine_VerifyHeader_Call) Run(run func(chain consensus.ChainHeaderReader, header *types.Header)) *Engine_VerifyHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(consensus.ChainHeaderReader), args[1].(*types.Header))
	})
	return _c
}

func (_c *Engine_VerifyHeader_Call) Return(_a0 error) *Engine_VerifyHeader_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Engine_VerifyHeader_Call) RunAndReturn(run func(consensus.ChainHeaderReader, *types.Header) error) *Engine_VerifyHeader_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyHeaders provides a mock function with given fields: chain, headers
func (_m *Engine) VerifyHeaders(chain consensus.ChainHeaderReader, headers []*types.Header) (chan<- struct{}, <-chan error) {
	ret := _m.Called(chain, headers)

	var r0 chan<- struct{}
	var r1 <-chan error
	if rf, ok := ret.Get(0).(func(consensus.ChainHeaderReader, []*types.Header) (chan<- struct{}, <-chan error)); ok {
		return rf(chain, headers)
	}
	if rf, ok := ret.Get(0).(func(consensus.ChainHeaderReader, []*types.Header) chan<- struct{}); ok {
		r0 = rf(chain, headers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan<- struct{})
		}
	}

	if rf, ok := ret.Get(1).(func(consensus.ChainHeaderReader, []*types.Header) <-chan error); ok {
		r1 = rf(chain, headers)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(<-chan error)
		}
	}

	return r0, r1
}

// Engine_VerifyHeaders_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyHeaders'
type Engine_VerifyHeaders_Call struct {
	*mock.Call
}

// VerifyHeaders is a helper method to define mock.On call
//   - chain consensus.ChainHeaderReader
//   - headers []*types.Header
func (_e *Engine_Expecter) VerifyHeaders(chain interface{}, headers interface{}) *Engine_VerifyHeaders_Call {
	return &Engine_VerifyHeaders_Call{Call: _e.mock.On("VerifyHeaders", chain, headers)}
}

func (_c *Engine_VerifyHeaders_Call) Run(run func(chain consensus.ChainHeaderReader, headers []*types.Header)) *Engine_VerifyHeaders_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(consensus.ChainHeaderReader), args[1].([]*types.Header))
	})
	return _c
}

func (_c *Engine_VerifyHeaders_Call) Return(_a0 chan<- struct{}, _a1 <-chan error) *Engine_VerifyHeaders_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Engine_VerifyHeaders_Call) RunAndReturn(run func(consensus.ChainHeaderReader, []*types.Header) (chan<- struct{}, <-chan error)) *Engine_VerifyHeaders_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyUncles provides a mock function with given fields: chain, block
func (_m *Engine) VerifyUncles(chain consensus.ChainReader, block *types.Block) error {
	ret := _m.Called(chain, block)

	var r0 error
	if rf, ok := ret.Get(0).(func(consensus.ChainReader, *types.Block) error); ok {
		r0 = rf(chain, block)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Engine_VerifyUncles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyUncles'
type Engine_VerifyUncles_Call struct {
	*mock.Call
}

// VerifyUncles is a helper method to define mock.On call
//   - chain consensus.ChainReader
//   - block *types.Block
func (_e *Engine_Expecter) VerifyUncles(chain interface{}, block interface{}) *Engine_VerifyUncles_Call {
	return &Engine_VerifyUncles_Call{Call: _e.mock.On("VerifyUncles", chain, block)}
}

func (_c *Engine_VerifyUncles_Call) Run(run func(chain consensus.ChainReader, block *types.Block)) *Engine_VerifyUncles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(consensus.ChainReader), args[1].(*types.Block))
	})
	return _c
}

func (_c *Engine_VerifyUncles_Call) Return(_a0 error) *Engine_VerifyUncles_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Engine_VerifyUncles_Call) RunAndReturn(run func(consensus.ChainReader, *types.Block) error) *Engine_VerifyUncles_Call {
	_c.Call.Return(run)
	return _c
}

// NewEngine creates a new instance of Engine. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEngine(t interface {
	mock.TestingT
	Cleanup(func())
}) *Engine {
	mock := &Engine{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
