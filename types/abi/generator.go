// Copyright (C) 2023, Berachain Foundation. All rights reserved.
// See the file LICENSE for licensing terms.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package abi

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
)

const abiPkg = "github.com/berachain/stargazer/types/abi"

type Generator struct {
	packageName string
	inputPath   string
	outputPath  string
}

func NewGenerator(packageName, inputPath, outputPath string) *Generator {
	return &Generator{
		packageName: packageName,
		inputPath:   inputPath,
		outputPath:  outputPath,
	}
}

func (g *Generator) Generate(varName string) error {
	// Read the JSON data from the file.
	data, err := os.ReadFile(g.inputPath)
	if err != nil {
		return err
	}

	// Declare a variable to hold the unmarshaled JSON data.
	var i interface{}

	// Unmarshal the JSON data into the forgeJSON variable.
	if err = json.Unmarshal(data, &i); err != nil {
		panic(err)
	}

	// Load ABI String.
	abiString := i.(map[string]interface{})["abi"]
	abiStringMarshalled, err := json.Marshal(abiString)
	if err != nil {
		panic(err)
	}

	// Load Bytecode String.
	bytecode := i.(map[string]interface{})["bytecode"].(map[string]interface{})["object"]
	bytecodeMarshalled, err := json.Marshal(bytecode)
	if err != nil {
		panic(err)
	}

	// Build the golang file.
	f := jen.NewFilePath(g.packageName)
	f.HeaderComment("Code generated by stargazer. DO NOT EDIT.")
	f.Var().Id(varName).Qual(abiPkg, "CompiliedContract")

	f.Func().Id("init").Params().Block(
		jen.Id(varName).Op("=").Qual(abiPkg, "BuildCompiledContract").Call(
			jen.Id("\""+strings.ReplaceAll(string(abiStringMarshalled), "\"", "\\\"")+"\""),
			jen.Id(string(bytecodeMarshalled)),
		),
	)

	// Create Path.
	outFile, err := os.Create(g.outputPath)
	if err != nil {
		log.Fatal(err)
	}

	// Output to file.
	n, err := outFile.WriteString(fmt.Sprintf("%#v", f) + "\n")
	if err != nil {
		return err
	}

	// Sync the file.
	if err = outFile.Sync(); err != nil {
		return err
	}

	//nolint: forbidigo // meh its okay for now.
	fmt.Printf("\nwrote %d bytes to %s", n, g.outputPath)

	return nil
}
