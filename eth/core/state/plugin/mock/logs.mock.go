// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/berachain/stargazer/eth/core/state"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"sync"
)

// Ensure, that LogsPluginMock does implement state.LogsPlugin.
// If this is not the case, regenerate this file with moq.
var _ state.LogsPlugin = &LogsPluginMock{}

// LogsPluginMock is a mock implementation of state.LogsPlugin.
//
//	func TestSomethingThatUsesLogsPlugin(t *testing.T) {
//
//		// make and configure a mocked state.LogsPlugin
//		mockedLogsPlugin := &LogsPluginMock{
//			AddLogFunc: func(log *types.Log)  {
//				panic("mock out the AddLog method")
//			},
//			BuildLogsAndClearFunc: func(hash1 common.Hash, hash2 common.Hash, v1 uint, v2 uint) []*types.Log {
//				panic("mock out the BuildLogsAndClear method")
//			},
//			FinalizeFunc: func()  {
//				panic("mock out the Finalize method")
//			},
//			RegistryKeyFunc: func() string {
//				panic("mock out the RegistryKey method")
//			},
//			RevertToSnapshotFunc: func(n int)  {
//				panic("mock out the RevertToSnapshot method")
//			},
//			SnapshotFunc: func() int {
//				panic("mock out the Snapshot method")
//			},
//		}
//
//		// use mockedLogsPlugin in code that requires state.LogsPlugin
//		// and then make assertions.
//
//	}
type LogsPluginMock struct {
	// AddLogFunc mocks the AddLog method.
	AddLogFunc func(log *types.Log)

	// BuildLogsAndClearFunc mocks the BuildLogsAndClear method.
	BuildLogsAndClearFunc func(hash1 common.Hash, hash2 common.Hash, v1 uint, v2 uint) []*types.Log

	// FinalizeFunc mocks the Finalize method.
	FinalizeFunc func()

	// RegistryKeyFunc mocks the RegistryKey method.
	RegistryKeyFunc func() string

	// RevertToSnapshotFunc mocks the RevertToSnapshot method.
	RevertToSnapshotFunc func(n int)

	// SnapshotFunc mocks the Snapshot method.
	SnapshotFunc func() int

	// calls tracks calls to the methods.
	calls struct {
		// AddLog holds details about calls to the AddLog method.
		AddLog []struct {
			// Log is the log argument value.
			Log *types.Log
		}
		// BuildLogsAndClear holds details about calls to the BuildLogsAndClear method.
		BuildLogsAndClear []struct {
			// Hash1 is the hash1 argument value.
			Hash1 common.Hash
			// Hash2 is the hash2 argument value.
			Hash2 common.Hash
			// V1 is the v1 argument value.
			V1 uint
			// V2 is the v2 argument value.
			V2 uint
		}
		// Finalize holds details about calls to the Finalize method.
		Finalize []struct {
		}
		// RegistryKey holds details about calls to the RegistryKey method.
		RegistryKey []struct {
		}
		// RevertToSnapshot holds details about calls to the RevertToSnapshot method.
		RevertToSnapshot []struct {
			// N is the n argument value.
			N int
		}
		// Snapshot holds details about calls to the Snapshot method.
		Snapshot []struct {
		}
	}
	lockAddLog            sync.RWMutex
	lockBuildLogsAndClear sync.RWMutex
	lockFinalize          sync.RWMutex
	lockRegistryKey       sync.RWMutex
	lockRevertToSnapshot  sync.RWMutex
	lockSnapshot          sync.RWMutex
}

// AddLog calls AddLogFunc.
func (mock *LogsPluginMock) AddLog(log *types.Log) {
	if mock.AddLogFunc == nil {
		panic("LogsPluginMock.AddLogFunc: method is nil but LogsPlugin.AddLog was just called")
	}
	callInfo := struct {
		Log *types.Log
	}{
		Log: log,
	}
	mock.lockAddLog.Lock()
	mock.calls.AddLog = append(mock.calls.AddLog, callInfo)
	mock.lockAddLog.Unlock()
	mock.AddLogFunc(log)
}

// AddLogCalls gets all the calls that were made to AddLog.
// Check the length with:
//
//	len(mockedLogsPlugin.AddLogCalls())
func (mock *LogsPluginMock) AddLogCalls() []struct {
	Log *types.Log
} {
	var calls []struct {
		Log *types.Log
	}
	mock.lockAddLog.RLock()
	calls = mock.calls.AddLog
	mock.lockAddLog.RUnlock()
	return calls
}

// BuildLogsAndClear calls BuildLogsAndClearFunc.
func (mock *LogsPluginMock) BuildLogsAndClear(hash1 common.Hash, hash2 common.Hash, v1 uint, v2 uint) []*types.Log {
	if mock.BuildLogsAndClearFunc == nil {
		panic("LogsPluginMock.BuildLogsAndClearFunc: method is nil but LogsPlugin.BuildLogsAndClear was just called")
	}
	callInfo := struct {
		Hash1 common.Hash
		Hash2 common.Hash
		V1    uint
		V2    uint
	}{
		Hash1: hash1,
		Hash2: hash2,
		V1:    v1,
		V2:    v2,
	}
	mock.lockBuildLogsAndClear.Lock()
	mock.calls.BuildLogsAndClear = append(mock.calls.BuildLogsAndClear, callInfo)
	mock.lockBuildLogsAndClear.Unlock()
	return mock.BuildLogsAndClearFunc(hash1, hash2, v1, v2)
}

// BuildLogsAndClearCalls gets all the calls that were made to BuildLogsAndClear.
// Check the length with:
//
//	len(mockedLogsPlugin.BuildLogsAndClearCalls())
func (mock *LogsPluginMock) BuildLogsAndClearCalls() []struct {
	Hash1 common.Hash
	Hash2 common.Hash
	V1    uint
	V2    uint
} {
	var calls []struct {
		Hash1 common.Hash
		Hash2 common.Hash
		V1    uint
		V2    uint
	}
	mock.lockBuildLogsAndClear.RLock()
	calls = mock.calls.BuildLogsAndClear
	mock.lockBuildLogsAndClear.RUnlock()
	return calls
}

// Finalize calls FinalizeFunc.
func (mock *LogsPluginMock) Finalize() {
	if mock.FinalizeFunc == nil {
		panic("LogsPluginMock.FinalizeFunc: method is nil but LogsPlugin.Finalize was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFinalize.Lock()
	mock.calls.Finalize = append(mock.calls.Finalize, callInfo)
	mock.lockFinalize.Unlock()
	mock.FinalizeFunc()
}

// FinalizeCalls gets all the calls that were made to Finalize.
// Check the length with:
//
//	len(mockedLogsPlugin.FinalizeCalls())
func (mock *LogsPluginMock) FinalizeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFinalize.RLock()
	calls = mock.calls.Finalize
	mock.lockFinalize.RUnlock()
	return calls
}

// RegistryKey calls RegistryKeyFunc.
func (mock *LogsPluginMock) RegistryKey() string {
	if mock.RegistryKeyFunc == nil {
		panic("LogsPluginMock.RegistryKeyFunc: method is nil but LogsPlugin.RegistryKey was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRegistryKey.Lock()
	mock.calls.RegistryKey = append(mock.calls.RegistryKey, callInfo)
	mock.lockRegistryKey.Unlock()
	return mock.RegistryKeyFunc()
}

// RegistryKeyCalls gets all the calls that were made to RegistryKey.
// Check the length with:
//
//	len(mockedLogsPlugin.RegistryKeyCalls())
func (mock *LogsPluginMock) RegistryKeyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRegistryKey.RLock()
	calls = mock.calls.RegistryKey
	mock.lockRegistryKey.RUnlock()
	return calls
}

// RevertToSnapshot calls RevertToSnapshotFunc.
func (mock *LogsPluginMock) RevertToSnapshot(n int) {
	if mock.RevertToSnapshotFunc == nil {
		panic("LogsPluginMock.RevertToSnapshotFunc: method is nil but LogsPlugin.RevertToSnapshot was just called")
	}
	callInfo := struct {
		N int
	}{
		N: n,
	}
	mock.lockRevertToSnapshot.Lock()
	mock.calls.RevertToSnapshot = append(mock.calls.RevertToSnapshot, callInfo)
	mock.lockRevertToSnapshot.Unlock()
	mock.RevertToSnapshotFunc(n)
}

// RevertToSnapshotCalls gets all the calls that were made to RevertToSnapshot.
// Check the length with:
//
//	len(mockedLogsPlugin.RevertToSnapshotCalls())
func (mock *LogsPluginMock) RevertToSnapshotCalls() []struct {
	N int
} {
	var calls []struct {
		N int
	}
	mock.lockRevertToSnapshot.RLock()
	calls = mock.calls.RevertToSnapshot
	mock.lockRevertToSnapshot.RUnlock()
	return calls
}

// Snapshot calls SnapshotFunc.
func (mock *LogsPluginMock) Snapshot() int {
	if mock.SnapshotFunc == nil {
		panic("LogsPluginMock.SnapshotFunc: method is nil but LogsPlugin.Snapshot was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSnapshot.Lock()
	mock.calls.Snapshot = append(mock.calls.Snapshot, callInfo)
	mock.lockSnapshot.Unlock()
	return mock.SnapshotFunc()
}

// SnapshotCalls gets all the calls that were made to Snapshot.
// Check the length with:
//
//	len(mockedLogsPlugin.SnapshotCalls())
func (mock *LogsPluginMock) SnapshotCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSnapshot.RLock()
	calls = mock.calls.Snapshot
	mock.lockSnapshot.RUnlock()
	return calls
}
