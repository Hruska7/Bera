// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/berachain/stargazer/eth/core"
	"sync"
)

// Ensure, that GasPluginMock does implement core.GasPlugin.
// If this is not the case, regenerate this file with moq.
var _ core.GasPlugin = &GasPluginMock{}

// GasPluginMock is a mock implementation of core.GasPlugin.
//
//	func TestSomethingThatUsesGasPlugin(t *testing.T) {
//
//		// make and configure a mocked core.GasPlugin
//		mockedGasPlugin := &GasPluginMock{
//			ConsumeGasFunc: func(amount uint64) error {
//				panic("mock out the ConsumeGas method")
//			},
//			CumulativeGasUsedFunc: func() uint64 {
//				panic("mock out the CumulativeGasUsed method")
//			},
//			GasRemainingFunc: func() uint64 {
//				panic("mock out the GasRemaining method")
//			},
//			GasUsedFunc: func() uint64 {
//				panic("mock out the GasUsed method")
//			},
//			RefundGasFunc: func(amount uint64)  {
//				panic("mock out the RefundGas method")
//			},
//			SetGasLimitFunc: func(amount uint64) error {
//				panic("mock out the SetGasLimit method")
//			},
//			SetupFunc: func() error {
//				panic("mock out the Setup method")
//			},
//		}
//
//		// use mockedGasPlugin in code that requires core.GasPlugin
//		// and then make assertions.
//
//	}
type GasPluginMock struct {
	// ConsumeGasFunc mocks the ConsumeGas method.
	ConsumeGasFunc func(amount uint64) error

	// CumulativeGasUsedFunc mocks the CumulativeGasUsed method.
	CumulativeGasUsedFunc func() uint64

	// GasRemainingFunc mocks the GasRemaining method.
	GasRemainingFunc func() uint64

	// GasUsedFunc mocks the GasUsed method.
	GasUsedFunc func() uint64

	// RefundGasFunc mocks the RefundGas method.
	RefundGasFunc func(amount uint64)

	// SetGasLimitFunc mocks the SetGasLimit method.
	SetGasLimitFunc func(amount uint64) error

	// SetupFunc mocks the Setup method.
	SetupFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// ConsumeGas holds details about calls to the ConsumeGas method.
		ConsumeGas []struct {
			// Amount is the amount argument value.
			Amount uint64
		}
		// CumulativeGasUsed holds details about calls to the CumulativeGasUsed method.
		CumulativeGasUsed []struct {
		}
		// GasRemaining holds details about calls to the GasRemaining method.
		GasRemaining []struct {
		}
		// GasUsed holds details about calls to the GasUsed method.
		GasUsed []struct {
		}
		// RefundGas holds details about calls to the RefundGas method.
		RefundGas []struct {
			// Amount is the amount argument value.
			Amount uint64
		}
		// SetGasLimit holds details about calls to the SetGasLimit method.
		SetGasLimit []struct {
			// Amount is the amount argument value.
			Amount uint64
		}
		// Setup holds details about calls to the Setup method.
		Setup []struct {
		}
	}
	lockConsumeGas        sync.RWMutex
	lockCumulativeGasUsed sync.RWMutex
	lockGasRemaining      sync.RWMutex
	lockGasUsed           sync.RWMutex
	lockRefundGas         sync.RWMutex
	lockSetGasLimit       sync.RWMutex
	lockSetup             sync.RWMutex
}

// ConsumeGas calls ConsumeGasFunc.
func (mock *GasPluginMock) ConsumeGas(amount uint64) error {
	if mock.ConsumeGasFunc == nil {
		panic("GasPluginMock.ConsumeGasFunc: method is nil but GasPlugin.ConsumeGas was just called")
	}
	callInfo := struct {
		Amount uint64
	}{
		Amount: amount,
	}
	mock.lockConsumeGas.Lock()
	mock.calls.ConsumeGas = append(mock.calls.ConsumeGas, callInfo)
	mock.lockConsumeGas.Unlock()
	return mock.ConsumeGasFunc(amount)
}

// ConsumeGasCalls gets all the calls that were made to ConsumeGas.
// Check the length with:
//
//	len(mockedGasPlugin.ConsumeGasCalls())
func (mock *GasPluginMock) ConsumeGasCalls() []struct {
	Amount uint64
} {
	var calls []struct {
		Amount uint64
	}
	mock.lockConsumeGas.RLock()
	calls = mock.calls.ConsumeGas
	mock.lockConsumeGas.RUnlock()
	return calls
}

// CumulativeGasUsed calls CumulativeGasUsedFunc.
func (mock *GasPluginMock) CumulativeGasUsed() uint64 {
	if mock.CumulativeGasUsedFunc == nil {
		panic("GasPluginMock.CumulativeGasUsedFunc: method is nil but GasPlugin.CumulativeGasUsed was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCumulativeGasUsed.Lock()
	mock.calls.CumulativeGasUsed = append(mock.calls.CumulativeGasUsed, callInfo)
	mock.lockCumulativeGasUsed.Unlock()
	return mock.CumulativeGasUsedFunc()
}

// CumulativeGasUsedCalls gets all the calls that were made to CumulativeGasUsed.
// Check the length with:
//
//	len(mockedGasPlugin.CumulativeGasUsedCalls())
func (mock *GasPluginMock) CumulativeGasUsedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCumulativeGasUsed.RLock()
	calls = mock.calls.CumulativeGasUsed
	mock.lockCumulativeGasUsed.RUnlock()
	return calls
}

// GasRemaining calls GasRemainingFunc.
func (mock *GasPluginMock) GasRemaining() uint64 {
	if mock.GasRemainingFunc == nil {
		panic("GasPluginMock.GasRemainingFunc: method is nil but GasPlugin.GasRemaining was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGasRemaining.Lock()
	mock.calls.GasRemaining = append(mock.calls.GasRemaining, callInfo)
	mock.lockGasRemaining.Unlock()
	return mock.GasRemainingFunc()
}

// GasRemainingCalls gets all the calls that were made to GasRemaining.
// Check the length with:
//
//	len(mockedGasPlugin.GasRemainingCalls())
func (mock *GasPluginMock) GasRemainingCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGasRemaining.RLock()
	calls = mock.calls.GasRemaining
	mock.lockGasRemaining.RUnlock()
	return calls
}

// GasUsed calls GasUsedFunc.
func (mock *GasPluginMock) GasUsed() uint64 {
	if mock.GasUsedFunc == nil {
		panic("GasPluginMock.GasUsedFunc: method is nil but GasPlugin.GasUsed was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGasUsed.Lock()
	mock.calls.GasUsed = append(mock.calls.GasUsed, callInfo)
	mock.lockGasUsed.Unlock()
	return mock.GasUsedFunc()
}

// GasUsedCalls gets all the calls that were made to GasUsed.
// Check the length with:
//
//	len(mockedGasPlugin.GasUsedCalls())
func (mock *GasPluginMock) GasUsedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGasUsed.RLock()
	calls = mock.calls.GasUsed
	mock.lockGasUsed.RUnlock()
	return calls
}

// RefundGas calls RefundGasFunc.
func (mock *GasPluginMock) RefundGas(amount uint64) {
	if mock.RefundGasFunc == nil {
		panic("GasPluginMock.RefundGasFunc: method is nil but GasPlugin.RefundGas was just called")
	}
	callInfo := struct {
		Amount uint64
	}{
		Amount: amount,
	}
	mock.lockRefundGas.Lock()
	mock.calls.RefundGas = append(mock.calls.RefundGas, callInfo)
	mock.lockRefundGas.Unlock()
	mock.RefundGasFunc(amount)
}

// RefundGasCalls gets all the calls that were made to RefundGas.
// Check the length with:
//
//	len(mockedGasPlugin.RefundGasCalls())
func (mock *GasPluginMock) RefundGasCalls() []struct {
	Amount uint64
} {
	var calls []struct {
		Amount uint64
	}
	mock.lockRefundGas.RLock()
	calls = mock.calls.RefundGas
	mock.lockRefundGas.RUnlock()
	return calls
}

// SetGasLimit calls SetGasLimitFunc.
func (mock *GasPluginMock) SetGasLimit(amount uint64) error {
	if mock.SetGasLimitFunc == nil {
		panic("GasPluginMock.SetGasLimitFunc: method is nil but GasPlugin.SetGasLimit was just called")
	}
	callInfo := struct {
		Amount uint64
	}{
		Amount: amount,
	}
	mock.lockSetGasLimit.Lock()
	mock.calls.SetGasLimit = append(mock.calls.SetGasLimit, callInfo)
	mock.lockSetGasLimit.Unlock()
	return mock.SetGasLimitFunc(amount)
}

// SetGasLimitCalls gets all the calls that were made to SetGasLimit.
// Check the length with:
//
//	len(mockedGasPlugin.SetGasLimitCalls())
func (mock *GasPluginMock) SetGasLimitCalls() []struct {
	Amount uint64
} {
	var calls []struct {
		Amount uint64
	}
	mock.lockSetGasLimit.RLock()
	calls = mock.calls.SetGasLimit
	mock.lockSetGasLimit.RUnlock()
	return calls
}

// Setup calls SetupFunc.
func (mock *GasPluginMock) Setup() error {
	if mock.SetupFunc == nil {
		panic("GasPluginMock.SetupFunc: method is nil but GasPlugin.Setup was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSetup.Lock()
	mock.calls.Setup = append(mock.calls.Setup, callInfo)
	mock.lockSetup.Unlock()
	return mock.SetupFunc()
}

// SetupCalls gets all the calls that were made to Setup.
// Check the length with:
//
//	len(mockedGasPlugin.SetupCalls())
func (mock *GasPluginMock) SetupCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSetup.RLock()
	calls = mock.calls.Setup
	mock.lockSetup.RUnlock()
	return calls
}
