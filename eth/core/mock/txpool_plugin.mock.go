// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/ethereum/go-ethereum/common"
	ethereumcore "github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
	"github.com/gofrs/uuid"
	ethcore "pkg.berachain.dev/polaris/eth/core"
	"sync"
)

// Ensure, that TxPoolPluginMock does implement ethcore.TxPoolPlugin.
// If this is not the case, regenerate this file with moq.
var _ ethcore.TxPoolPlugin = &TxPoolPluginMock{}

// TxPoolPluginMock is a mock implementation of ethcore.TxPoolPlugin.
//
//	func TestSomethingThatUsesTxPoolPlugin(t *testing.T) {
//
//		// make and configure a mocked ethcore.TxPoolPlugin
//		mockedTxPoolPlugin := &TxPoolPluginMock{
//			ContentFunc: func() (map[common.Address]types.Transactions, map[common.Address]types.Transactions) {
//				panic("mock out the Content method")
//			},
//			ContentFromFunc: func(addr common.Address) (types.Transactions, types.Transactions) {
//				panic("mock out the ContentFrom method")
//			},
//			GetFunc: func(hash common.Hash) *types.Transaction {
//				panic("mock out the Get method")
//			},
//			NonceFunc: func(address common.Address) uint64 {
//				panic("mock out the Nonce method")
//			},
//			PendingFunc: func(b bool) map[common.Address]types.Transactions {
//				panic("mock out the Pending method")
//			},
//			SendBundleFunc: func(txs types.Transactions, blockNumber int64, uuidMoqParam uuid.UUID, signingAddress common.Address, minTimestamp uint64, maxTimestamp uint64, revertingTxHashes []common.Hash) error {
//				panic("mock out the SendBundle method")
//			},
//			SendPrivTxFunc: func(tx *types.Transaction) error {
//				panic("mock out the SendPrivTx method")
//			},
//			SendTxFunc: func(tx *types.Transaction) error {
//				panic("mock out the SendTx method")
//			},
//			StatsFunc: func() (int, int) {
//				panic("mock out the Stats method")
//			},
//			SubscribeNewTxsEventFunc: func(ch chan<- ethereumcore.NewTxsEvent) event.Subscription {
//				panic("mock out the SubscribeNewTxsEvent method")
//			},
//		}
//
//		// use mockedTxPoolPlugin in code that requires ethcore.TxPoolPlugin
//		// and then make assertions.
//
//	}
type TxPoolPluginMock struct {
	// ContentFunc mocks the Content method.
	ContentFunc func() (map[common.Address]types.Transactions, map[common.Address]types.Transactions)

	// ContentFromFunc mocks the ContentFrom method.
	ContentFromFunc func(addr common.Address) (types.Transactions, types.Transactions)

	// GetFunc mocks the Get method.
	GetFunc func(hash common.Hash) *types.Transaction

	// NonceFunc mocks the Nonce method.
	NonceFunc func(address common.Address) uint64

	// PendingFunc mocks the Pending method.
	PendingFunc func(b bool) map[common.Address]types.Transactions

	// SendBundleFunc mocks the SendBundle method.
	SendBundleFunc func(txs types.Transactions, blockNumber int64, uuidMoqParam uuid.UUID, signingAddress common.Address, minTimestamp uint64, maxTimestamp uint64, revertingTxHashes []common.Hash) error

	// SendPrivTxFunc mocks the SendPrivTx method.
	SendPrivTxFunc func(tx *types.Transaction) error

	// SendTxFunc mocks the SendTx method.
	SendTxFunc func(tx *types.Transaction) error

	// StatsFunc mocks the Stats method.
	StatsFunc func() (int, int)

	// SubscribeNewTxsEventFunc mocks the SubscribeNewTxsEvent method.
	SubscribeNewTxsEventFunc func(ch chan<- ethereumcore.NewTxsEvent) event.Subscription

	// calls tracks calls to the methods.
	calls struct {
		// Content holds details about calls to the Content method.
		Content []struct {
		}
		// ContentFrom holds details about calls to the ContentFrom method.
		ContentFrom []struct {
			// Addr is the addr argument value.
			Addr common.Address
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Hash is the hash argument value.
			Hash common.Hash
		}
		// Nonce holds details about calls to the Nonce method.
		Nonce []struct {
			// Address is the address argument value.
			Address common.Address
		}
		// Pending holds details about calls to the Pending method.
		Pending []struct {
			// B is the b argument value.
			B bool
		}
		// SendBundle holds details about calls to the SendBundle method.
		SendBundle []struct {
			// Txs is the txs argument value.
			Txs types.Transactions
			// BlockNumber is the blockNumber argument value.
			BlockNumber int64
			// UuidMoqParam is the uuidMoqParam argument value.
			UuidMoqParam uuid.UUID
			// SigningAddress is the signingAddress argument value.
			SigningAddress common.Address
			// MinTimestamp is the minTimestamp argument value.
			MinTimestamp uint64
			// MaxTimestamp is the maxTimestamp argument value.
			MaxTimestamp uint64
			// RevertingTxHashes is the revertingTxHashes argument value.
			RevertingTxHashes []common.Hash
		}
		// SendPrivTx holds details about calls to the SendPrivTx method.
		SendPrivTx []struct {
			// Tx is the tx argument value.
			Tx *types.Transaction
		}
		// SendTx holds details about calls to the SendTx method.
		SendTx []struct {
			// Tx is the tx argument value.
			Tx *types.Transaction
		}
		// Stats holds details about calls to the Stats method.
		Stats []struct {
		}
		// SubscribeNewTxsEvent holds details about calls to the SubscribeNewTxsEvent method.
		SubscribeNewTxsEvent []struct {
			// Ch is the ch argument value.
			Ch chan<- ethereumcore.NewTxsEvent
		}
	}
	lockContent              sync.RWMutex
	lockContentFrom          sync.RWMutex
	lockGet                  sync.RWMutex
	lockNonce                sync.RWMutex
	lockPending              sync.RWMutex
	lockSendBundle           sync.RWMutex
	lockSendPrivTx           sync.RWMutex
	lockSendTx               sync.RWMutex
	lockStats                sync.RWMutex
	lockSubscribeNewTxsEvent sync.RWMutex
}

// Content calls ContentFunc.
func (mock *TxPoolPluginMock) Content() (map[common.Address]types.Transactions, map[common.Address]types.Transactions) {
	if mock.ContentFunc == nil {
		panic("TxPoolPluginMock.ContentFunc: method is nil but TxPoolPlugin.Content was just called")
	}
	callInfo := struct {
	}{}
	mock.lockContent.Lock()
	mock.calls.Content = append(mock.calls.Content, callInfo)
	mock.lockContent.Unlock()
	return mock.ContentFunc()
}

// ContentCalls gets all the calls that were made to Content.
// Check the length with:
//
//	len(mockedTxPoolPlugin.ContentCalls())
func (mock *TxPoolPluginMock) ContentCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockContent.RLock()
	calls = mock.calls.Content
	mock.lockContent.RUnlock()
	return calls
}

// ContentFrom calls ContentFromFunc.
func (mock *TxPoolPluginMock) ContentFrom(addr common.Address) (types.Transactions, types.Transactions) {
	if mock.ContentFromFunc == nil {
		panic("TxPoolPluginMock.ContentFromFunc: method is nil but TxPoolPlugin.ContentFrom was just called")
	}
	callInfo := struct {
		Addr common.Address
	}{
		Addr: addr,
	}
	mock.lockContentFrom.Lock()
	mock.calls.ContentFrom = append(mock.calls.ContentFrom, callInfo)
	mock.lockContentFrom.Unlock()
	return mock.ContentFromFunc(addr)
}

// ContentFromCalls gets all the calls that were made to ContentFrom.
// Check the length with:
//
//	len(mockedTxPoolPlugin.ContentFromCalls())
func (mock *TxPoolPluginMock) ContentFromCalls() []struct {
	Addr common.Address
} {
	var calls []struct {
		Addr common.Address
	}
	mock.lockContentFrom.RLock()
	calls = mock.calls.ContentFrom
	mock.lockContentFrom.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *TxPoolPluginMock) Get(hash common.Hash) *types.Transaction {
	if mock.GetFunc == nil {
		panic("TxPoolPluginMock.GetFunc: method is nil but TxPoolPlugin.Get was just called")
	}
	callInfo := struct {
		Hash common.Hash
	}{
		Hash: hash,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(hash)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedTxPoolPlugin.GetCalls())
func (mock *TxPoolPluginMock) GetCalls() []struct {
	Hash common.Hash
} {
	var calls []struct {
		Hash common.Hash
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Nonce calls NonceFunc.
func (mock *TxPoolPluginMock) Nonce(address common.Address) uint64 {
	if mock.NonceFunc == nil {
		panic("TxPoolPluginMock.NonceFunc: method is nil but TxPoolPlugin.Nonce was just called")
	}
	callInfo := struct {
		Address common.Address
	}{
		Address: address,
	}
	mock.lockNonce.Lock()
	mock.calls.Nonce = append(mock.calls.Nonce, callInfo)
	mock.lockNonce.Unlock()
	return mock.NonceFunc(address)
}

// NonceCalls gets all the calls that were made to Nonce.
// Check the length with:
//
//	len(mockedTxPoolPlugin.NonceCalls())
func (mock *TxPoolPluginMock) NonceCalls() []struct {
	Address common.Address
} {
	var calls []struct {
		Address common.Address
	}
	mock.lockNonce.RLock()
	calls = mock.calls.Nonce
	mock.lockNonce.RUnlock()
	return calls
}

// Pending calls PendingFunc.
func (mock *TxPoolPluginMock) Pending(b bool) map[common.Address]types.Transactions {
	if mock.PendingFunc == nil {
		panic("TxPoolPluginMock.PendingFunc: method is nil but TxPoolPlugin.Pending was just called")
	}
	callInfo := struct {
		B bool
	}{
		B: b,
	}
	mock.lockPending.Lock()
	mock.calls.Pending = append(mock.calls.Pending, callInfo)
	mock.lockPending.Unlock()
	return mock.PendingFunc(b)
}

// PendingCalls gets all the calls that were made to Pending.
// Check the length with:
//
//	len(mockedTxPoolPlugin.PendingCalls())
func (mock *TxPoolPluginMock) PendingCalls() []struct {
	B bool
} {
	var calls []struct {
		B bool
	}
	mock.lockPending.RLock()
	calls = mock.calls.Pending
	mock.lockPending.RUnlock()
	return calls
}

// SendBundle calls SendBundleFunc.
func (mock *TxPoolPluginMock) SendBundle(txs types.Transactions, blockNumber int64, uuidMoqParam uuid.UUID, signingAddress common.Address, minTimestamp uint64, maxTimestamp uint64, revertingTxHashes []common.Hash) error {
	if mock.SendBundleFunc == nil {
		panic("TxPoolPluginMock.SendBundleFunc: method is nil but TxPoolPlugin.SendBundle was just called")
	}
	callInfo := struct {
		Txs               types.Transactions
		BlockNumber       int64
		UuidMoqParam      uuid.UUID
		SigningAddress    common.Address
		MinTimestamp      uint64
		MaxTimestamp      uint64
		RevertingTxHashes []common.Hash
	}{
		Txs:               txs,
		BlockNumber:       blockNumber,
		UuidMoqParam:      uuidMoqParam,
		SigningAddress:    signingAddress,
		MinTimestamp:      minTimestamp,
		MaxTimestamp:      maxTimestamp,
		RevertingTxHashes: revertingTxHashes,
	}
	mock.lockSendBundle.Lock()
	mock.calls.SendBundle = append(mock.calls.SendBundle, callInfo)
	mock.lockSendBundle.Unlock()
	return mock.SendBundleFunc(txs, blockNumber, uuidMoqParam, signingAddress, minTimestamp, maxTimestamp, revertingTxHashes)
}

// SendBundleCalls gets all the calls that were made to SendBundle.
// Check the length with:
//
//	len(mockedTxPoolPlugin.SendBundleCalls())
func (mock *TxPoolPluginMock) SendBundleCalls() []struct {
	Txs               types.Transactions
	BlockNumber       int64
	UuidMoqParam      uuid.UUID
	SigningAddress    common.Address
	MinTimestamp      uint64
	MaxTimestamp      uint64
	RevertingTxHashes []common.Hash
} {
	var calls []struct {
		Txs               types.Transactions
		BlockNumber       int64
		UuidMoqParam      uuid.UUID
		SigningAddress    common.Address
		MinTimestamp      uint64
		MaxTimestamp      uint64
		RevertingTxHashes []common.Hash
	}
	mock.lockSendBundle.RLock()
	calls = mock.calls.SendBundle
	mock.lockSendBundle.RUnlock()
	return calls
}

// SendPrivTx calls SendPrivTxFunc.
func (mock *TxPoolPluginMock) SendPrivTx(tx *types.Transaction) error {
	if mock.SendPrivTxFunc == nil {
		panic("TxPoolPluginMock.SendPrivTxFunc: method is nil but TxPoolPlugin.SendPrivTx was just called")
	}
	callInfo := struct {
		Tx *types.Transaction
	}{
		Tx: tx,
	}
	mock.lockSendPrivTx.Lock()
	mock.calls.SendPrivTx = append(mock.calls.SendPrivTx, callInfo)
	mock.lockSendPrivTx.Unlock()
	return mock.SendPrivTxFunc(tx)
}

// SendPrivTxCalls gets all the calls that were made to SendPrivTx.
// Check the length with:
//
//	len(mockedTxPoolPlugin.SendPrivTxCalls())
func (mock *TxPoolPluginMock) SendPrivTxCalls() []struct {
	Tx *types.Transaction
} {
	var calls []struct {
		Tx *types.Transaction
	}
	mock.lockSendPrivTx.RLock()
	calls = mock.calls.SendPrivTx
	mock.lockSendPrivTx.RUnlock()
	return calls
}

// SendTx calls SendTxFunc.
func (mock *TxPoolPluginMock) SendTx(tx *types.Transaction) error {
	if mock.SendTxFunc == nil {
		panic("TxPoolPluginMock.SendTxFunc: method is nil but TxPoolPlugin.SendTx was just called")
	}
	callInfo := struct {
		Tx *types.Transaction
	}{
		Tx: tx,
	}
	mock.lockSendTx.Lock()
	mock.calls.SendTx = append(mock.calls.SendTx, callInfo)
	mock.lockSendTx.Unlock()
	return mock.SendTxFunc(tx)
}

// SendTxCalls gets all the calls that were made to SendTx.
// Check the length with:
//
//	len(mockedTxPoolPlugin.SendTxCalls())
func (mock *TxPoolPluginMock) SendTxCalls() []struct {
	Tx *types.Transaction
} {
	var calls []struct {
		Tx *types.Transaction
	}
	mock.lockSendTx.RLock()
	calls = mock.calls.SendTx
	mock.lockSendTx.RUnlock()
	return calls
}

// Stats calls StatsFunc.
func (mock *TxPoolPluginMock) Stats() (int, int) {
	if mock.StatsFunc == nil {
		panic("TxPoolPluginMock.StatsFunc: method is nil but TxPoolPlugin.Stats was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStats.Lock()
	mock.calls.Stats = append(mock.calls.Stats, callInfo)
	mock.lockStats.Unlock()
	return mock.StatsFunc()
}

// StatsCalls gets all the calls that were made to Stats.
// Check the length with:
//
//	len(mockedTxPoolPlugin.StatsCalls())
func (mock *TxPoolPluginMock) StatsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStats.RLock()
	calls = mock.calls.Stats
	mock.lockStats.RUnlock()
	return calls
}

// SubscribeNewTxsEvent calls SubscribeNewTxsEventFunc.
func (mock *TxPoolPluginMock) SubscribeNewTxsEvent(ch chan<- ethereumcore.NewTxsEvent) event.Subscription {
	if mock.SubscribeNewTxsEventFunc == nil {
		panic("TxPoolPluginMock.SubscribeNewTxsEventFunc: method is nil but TxPoolPlugin.SubscribeNewTxsEvent was just called")
	}
	callInfo := struct {
		Ch chan<- ethereumcore.NewTxsEvent
	}{
		Ch: ch,
	}
	mock.lockSubscribeNewTxsEvent.Lock()
	mock.calls.SubscribeNewTxsEvent = append(mock.calls.SubscribeNewTxsEvent, callInfo)
	mock.lockSubscribeNewTxsEvent.Unlock()
	return mock.SubscribeNewTxsEventFunc(ch)
}

// SubscribeNewTxsEventCalls gets all the calls that were made to SubscribeNewTxsEvent.
// Check the length with:
//
//	len(mockedTxPoolPlugin.SubscribeNewTxsEventCalls())
func (mock *TxPoolPluginMock) SubscribeNewTxsEventCalls() []struct {
	Ch chan<- ethereumcore.NewTxsEvent
} {
	var calls []struct {
		Ch chan<- ethereumcore.NewTxsEvent
	}
	mock.lockSubscribeNewTxsEvent.RLock()
	calls = mock.calls.SubscribeNewTxsEvent
	mock.lockSubscribeNewTxsEvent.RUnlock()
	return calls
}
